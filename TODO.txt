+ Investigate GCC/Clang builtin atomic operations?

+ Add in mapping the same memory to two different processes
+ Create sensible thread handling
+ Add in init process loading
+ Make sure vmap is in 4K increments or whatever (fuck it, sure)
+ Remove/converge convnum and debugging __atoi
+ Create actual init program (meh, sort of)

+ Add in (attempting) to map into specific region of memory, see phone for
details dumbass
+ Primarily memory should be allocated to a process through mmap-like
functionality, but brk/sbrk can probably still be emulated. If s/brk maps memory
that's later attempted to mmap, it fails, and vice versa. Apparently should be
acceptable by Unix standards.
+ Alignment can maybe still be used, though more in the sense of using larger
pages? YES, CHECK common/vmem.c:map_fill_region! Should be implemented there as
well
+ check elf.c "skip while testing" comment, remove when sufficiently pleased
with the system. Christ, what a terrible way to develop software :D
+ Start working on syscalls etc.

+ NUMA is probably fairly easy to setup, just add more pmaps I guess, although
it does sort of mess with the current device memory setup, which assumes there
is only one memory region and everything below/above it is device memory
regions. Not entirely sure how to handle that situation, i.e. is it safe to
assume all devices are below the first NUMA node? No clue.

+ The dev interface can be abused, if a program decides to spam through all
memory addresses the system will probably run out of memory. Not sure if it's
worh doing anything to.
